Differential Drive Robot:
I chose to use the RoverRobotics robot because of my familiarity with the robots due to some prior exposure, as well as a good base for future expansion and deployment on an 
actual physical robot, as they already have a well-defined sim to implementation pipeline. 

Part 1: Path Smoothing
Algorithm: B-Spline Smoothing
Alternatives Tested: Linear Interpolation, Cubic Spline
Justification: Linear Interpolation was rejected due its lack of adaptability in situations where the system is expanded to include a local planner like A*. 
  Cubic Spline was rejected because on testing and simulation, it performed poorly when given non-uniform waypoints.
  B-Spline smoothing was selected because it is more robust to local changes, and stable with sharper turns, as well as with non-uniform waypoints.

Part 2: Trajectory Generation
Description: This node takes the /smooth_path generated by the path smoothing node (in (x,y) format), and converts it into [x,y,θ,v,ω,t] format. It essential parameterizes by time.
This node can be improved in future iterations to dynamically adjust rates with turn radius.

Part 3: Controller
Algorithm: Pure Pursuit
Alternatives Tested: PID Controller
Justification: The Pure Pursuit controller selects a lookahead point on the trajectory passed to it, and computes the curvature required to reach the point. This is then converted
  into the robots velocity commands. It is a simpler system than the PID controller, and hence was simpler to tune, and more robust. In the future, I would prefer to use a more optimized 
  controller such as LQR, or MPC to minimize the error.

Part 4: Future Improvements
I would extend this system to involve a global planner that would be capable of passing waypoints to the path smoothing node. One way to do this, especially in an indoor environment
  with some number of static obstacles, would be to use the inbuilt LIDAR (topic /scan), to build a map of the system. A global algorithm like A* or RRT* could then be used to plot a 
  path through the map, around the obstacles. For dynamic obstacles, output from the same LIDAR, or an additional camera could be used to identify dynamic obstacles, and a local planner
  like TEB, or MPPI could be used to avoid these obstacles. 

  For an alternate autonomous project with similar requirements, I have chosen to use the ROS2 Nav2 package, as well as the SLAM package to interface with a LIDAR, and an IMU for 
    localization, and planning. These are also an alternative to the previously defined system that leverage that leverage well tested and documented pre-existing packages, though at a
    computational cost.

Part 5: AI Tools Usage
I used Claude and ChatGPT to generate the baseline code, as well as to debug and iterate. 

  
    


  
